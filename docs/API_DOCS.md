# LindbladMPOSolver class

The `LindbladMPOSolver` class is the Python interface of the solver. By calling the `solve()` method, an input configuration file is created and the C++ solver is initiated using the created file as an input.

## Class parameters

The parameters of the class are passed in its initialization (as parameters of the constructor). It accepts 3 parameters:

* s_cygwin_path (str): The cygwin executable path for the C++ execution. Relevant only when running under Windows, the default value is "C:/cygwin64/bin/bash.exe".
* s_solver_path (str): The path of the compiled C++ solver executable file. It has a default value '/../bin/lindbladmpo'.
* parameters (dict): The simulation model parameters. For more information see below.

## Model parameters

All the model parameters are passed through the parameters dictionary in the class init function. For convenience, they are listed below by groups.

The default value for each parameter is indicated with an equality sign (only the first three parameters below have no default value and must be specified when the solver is invoked using the Python interface).

* Basic parameters:
    * N (int): The number of qubits in the lattice. This solver requires <img src="https://render.githubusercontent.com/render/math?math=N \geq 2" style="vertical-align:bottom">.
    * t_final (float): The final simulation time (<img src="https://render.githubusercontent.com/render/math?math=t_f" align=middle>).
    * tau (float): The discrete time step <img src="https://render.githubusercontent.com/render/math?math=\tau" style="vertical-align:bottom"> used in the time evolution.
    * t_init = 0 (float): The initial simulation time (<img src="https://render.githubusercontent.com/render/math?math=t_0" align=middle>). Must obey <img src="https://render.githubusercontent.com/render/math?math=t_0 \le t_f" align=middle>.
    * output_files_prefix = "lindblad" (str): The path and file name prefix to be used for the input file generated for the solver, as well as output files generated by the solver. The default value indicates saving files in the working directory with the file name prefix "lindblad". If only a directory path is given, the "lindblad" file name prefix will be added.
    * b_unique_id = False (bool): If True, a unique id will be generated for the simulation and appended to all generated file name prefixes.
* Hamiltonian coefficients:
    * h_x = 0 (float): The <img src="https://render.githubusercontent.com/render/math?math=h_{x,i}" > coefficient in the Hamiltonian. If a vector is given, it specifies <img src="https://render.githubusercontent.com/render/math?math=h_{x,i}" style="vertical-align:middle"> for each qubit. If a scalar is given, it is uniform for all qubits.
    * h_y = 0 (float): The <img src="https://render.githubusercontent.com/render/math?math=h_{y,i}" style="vertical-align:bottom"> coefficient in the Hamiltonian. If a vector is given, it specifies <img src="https://render.githubusercontent.com/render/math?math=h_{y,i}" style="vertical-align:bottom"> for each qubit. If a scalar is given, it is uniform for all qubits.
    * h_z = 0 (float): The <img src="https://render.githubusercontent.com/render/math?math=h_{z,i}" style="vertical-align:bottom"> coefficient in the Hamiltonian. If a vector is given, it specifies <img src="https://render.githubusercontent.com/render/math?math=h_{z,i}" style="vertical-align:bottom"> for each qubit. If a scalar is given, it is uniform for all qubits.
    * J_z = 0 (float): The <img src="https://render.githubusercontent.com/render/math?math=J^z_{ij}" style="vertical-align:bottom"> coefficient in the interaction part of the Hamiltonian. If a matrix is given, it specifies <img src="https://render.githubusercontent.com/render/math?math=J^z_{ij}" style="vertical-align:bottom"> for each pair of qubits. If a scalar is given, it is uniform for all qubits of a lattice. If either one of <img src="https://render.githubusercontent.com/render/math?math=J" style="vertical-align:bottom"> or <img src="https://render.githubusercontent.com/render/math?math=J_z" style="vertical-align:bottom"> is a matrix, then the other one must be either a matrix as well, or 0.
    * J = 0 (float): The <img src="https://render.githubusercontent.com/render/math?math=J_{ij}" style="vertical-align:bottom"> coefficient in the interaction part of the Hamiltonian. If a matrix is given, it specifies <img src="https://render.githubusercontent.com/render/math?math=J_{ij}" style="vertical-align:bottom"> for each pair of qubits. If a scalar is given, it is uniform for all qubits of a lattice. If either one of <img src="https://render.githubusercontent.com/render/math?math=J" style="vertical-align:bottom"> or <img src="https://render.githubusercontent.com/render/math?math=J_z" style="vertical-align:bottom"> is a matrix, then the other one must be either a matrix as well, or 0.
* Dissipation coefficients:
    * g_0 = 0 (float): The <img src="https://render.githubusercontent.com/render/math?math=g_{0,i}" style="vertical-align:bottom"> coefficient in the Lindbladian. If a vector is given, it specifies <img src="https://render.githubusercontent.com/render/math?math=g_{0,i}" style="vertical-align:bottom"> for each qubit. If a scalar is given, it is uniform for all qubits.
    * g_1 = 0 (float): The <img src="https://render.githubusercontent.com/render/math?math=g_{1,i}" style="vertical-align:bottom"> coefficient in the Lindbladian. If a vector is given, it specifies <img src="https://render.githubusercontent.com/render/math?math=g_{1,i}" style="vertical-align:bottom"> for each qubit. If a scalar is given, it is uniform for all qubits.
    * g_2 = 0 (float): The <img src="https://render.githubusercontent.com/render/math?math=g_{2,i}" style="vertical-align:bottom"> coefficient in the Lindbladian. If a vector is given, it specifies <img src="https://render.githubusercontent.com/render/math?math=g_{2,i}" style="vertical-align:bottom"> for each qubit. If a scalar is given, it is uniform for all qubits.
* Initial state:
    The initial state of the simulator either takes a predefined default value, is defined explicitly by the parameters, or is loaded from files saved by a previous solver execution. Using the initialization parameters the state can be initialized to a product state as detailed below, and then optional controlled-Z (CZ) gates can be applied to (some) pairs of qubits, which allows creating an initial (possibly nonideal) graph state.

    * init_product_state = "+z": A float (or a one-element float tuple), a tuple of two floats, a two-character string, or a length-N vector of such parameters. A single entry applies to all qubits. The supported strings take either the form "<img src="https://render.githubusercontent.com/render/math?math=\pm a" style="vertical-align:bottom">", or "id". The latter indicates the fully mixed-state (identity) density matrix, and the former indicate an eigenstate of one of the Pauli matrices,

      <img src="https://render.githubusercontent.com/render/math?math=\sigma_i^a\left|\pm a_i\rangle = \pm \right|\pm a_i\rangle." style="vertical-align:bottom">

      If an entry is a float, it should be between 0 and 1, and indicates the population of the "|0>" ("|up>" state, aligned with +z) in a diagonal mixed-state density matrix for the qubit. If an entry is a tuple of two floats (theta, phi), it indicates an arbitrary pure-state superposition in Bloch-sphere polar coordinates with the formula "cos(theta/2)|0> + sin(theta/2) exp{i phi}|1>".

	* init_cz_gates = []. A list of integer tuples that specify the qubit pairs for performing a controlled-Z gate on, after they are initialized according to 'init_product_state'. Currently the CZ gate is only supported on the qubits that are first initialized to a pure state.
    * init_graph_state = []. A list of integer tuples that specify the qubit pairs for performing a controlled-Z gate on, to generate an initial graph state, after first initializing all along the +x axis. If 'init_graph_state' is used, all other initialization parameters should be left empty. The qubit pairs will represent j and k in the graph state formula;

      <img src="https://render.githubusercontent.com/render/math?math=\left|\psi_0\rangle=%20\prod_{(j,k)\in%20V}{CZ}[j,k]%20\prod_i%20\right|%2b%20x_i\rangle" style="vertical-align:bottom">.
	* init_pauli_state = "": This initialization parameter is deprecated, use 'init_product_state' instead.
    * load_files_prefix = "" (str): The prefix of files as previously saved using the simulator, which the initial state has to be loaded from. An empty string indicates that the initial state is not loaded. If 'load_files_prefix' is used, all other initialization parameters should be left empty. See the parameter 'b_save_final_state' for more details on the saved files.
* Lattice specification:
    * l_x = 0 (float): The length of the lattice along the x dimension. In case of value 0, the number of qubits <img src="https://render.githubusercontent.com/render/math?math=N" style="vertical-align:bottom"> is used, and parameter l_y must be 1.
    * l_y = 1 (float): The length of the lattice along the y dimension.
    * b_periodic_x = False (bool): Whether periodic boundary conditions are applied along the x dimension. If True, then l_y must be 1. If False, open boundary conditions are used along the x dimension.
    * b_periodic_y = False (bool): Whether periodic boundary conditions are applied along the y dimension. If False, open boundary conditions are used along the y dimension.
* Numerical simulation control:
    * trotter_order = 4 (int): Trotter approximation order, Possible values are 2, 3, 4.
    * max_dim_rho = 400 (int): Maximum bond dimension for density matrices.
    * cut_off_rho = 1e-16 (float): Maximum truncation error (discarded Schmidt weight) for density matrices. The actual truncation is done using the most severe condition between cut_off_rho and max_dim_rho.
    * b_force_rho_trace = True (bool): Whether to force the density matrix trace to one by substituting <img src="https://render.githubusercontent.com/render/math?math=\rho \to\rho/ {\rm tr}\{\rho\}" style="vertical-align:bottom"> at every time step, compensating for some finite-step errors.
    * force_rho_hermitian_step = 4 (int): Determines every how many evolution time steps (<img src="https://render.githubusercontent.com/render/math?math=\tau" style="vertical-align:bottom">), to substitute <img src="https://render.githubusercontent.com/render/math?math=\rho \to (\rho %2b \rho^\dagger)/2" style="vertical-align:bottom">. This may reduce some errors, but is computationally expensive.
    * b_initial_rho_compression = True (bool): Whether a density matrix that is loaded from a previously saved state, should be re-gauged and compressed. Has no effect if the initial state is not loaded from a previously saved state.
* Observables and output:
    * 1q_indices = [] (list[int]): A list of integers that specify the qubits for which single-qubit observables will be calculated. In the case of an empty list, single-qubit observables will be calculated for all qubits.
    * 1q_components = ['Z'] (list[str]): A list of strings that specify the Pauli observables to compute for all qubits given in parameter "1q_indices". The allowed strings in the list are "x", "y", or "z" (lower or upper case). The observables results are saved using a file name ending with "obs-1q.dat".
    * 2q_indices = [] (list[tuple(int)]): A list of integer tuples that specify the qubit pairs for calculating two-qubit expectation values. In the case of an empty list, two-qubit expectation values will be calculated for all qubit pairs.
    * 2q_components = ['ZZ'] (list[str]): A list of strings that specify the two-qubit Pauli observables to compute for all qubit pairs given in parameter "2q_indices". The allowed strings in the list are one of "xx", "yy", "zz", "xy", "xz", "yz", "yx", "zx", "zy" (lower or upper case). The observables results are saved using a file name ending with ".obs-2q.dat".
    * output_step = 1 (int): How often (in integer steps of time <img src="https://render.githubusercontent.com/render/math?math=\tau" style="vertical-align:bottom">) the observables are computed. In case of the value 0, no observables will be computed.
    * b_save_final_state = False (bool): Whether to save the final state to files (Three binary files will be saved, whose names will have the prefix defined in "output_files_prefix").

## Class attributes

* LindbladMPOSolver.parameters: Returns the dict of model parameters.
* LindbladMPOSolver.s_input_file: Returns the path to the configuration file created for the C++ solver.
* LindbladMPOSolver.s_output_path: Returns the path to the output files.
* LindbladMPOSolver.s_cygwin_path: Returns the path to the cygwin executable used by the solver.
* LindbladMPOSolver.s_solver_path: Returns the path to the compiled C++ solver executable file.
* LindbladMPOSolver.s_id_suffix: Returns the solver instance unique id.
* LindbladMPOSolver.result: Returns the dictionary of results, described below.

## The result dictionary

 The result dictionary stores the outputs of the solver at all requested time steps, in three dictionaries whose keys are detailed in the following.
The stored data has a consistent format as detailed below.
* `obs-1q`. A dictionary for the one-qubit observables with the keys being
  a tuple with the format `(Pauli: str, qubit: tuple(int,))`. 
  The first key entry is the Pauli operator string (`x`, `y`, `z`),
  and the second key entry is a one-element tuple with the qubit number.
 Each value is a tuple, the first entry being a list with the times, and the second entry being the list of values of the observables at the indicated times.

* `obs-2q`. A dictionary for the two-qubit observables with the keys being a tuple with the format:
`(Pauli: str, qubit: tuple(int, int))`.
The first key entry is the Pauli operator string (`xx`, `xy`, etc.), and the second key entry is a two-element tuple with the two qubit numbers.
 Each value is a tuple, the first entry being a list with the times, and the second entry being the list of values of the observables at the indicated times.

* `global`. A dictionary for the global calculated quantities with the keys being a tuple with the format:
`(quantity: str, tuple())`.
The first key entry is the quantity string (`S_2`, `OSEE_center`, etc.), and the second key entry is an empty tuple.
 Each value is a tuple, the first entry being a list with the times, and the second entry being the list of values of the observables at the indicated times.


## Class methods

* solve(): Execute the C++ solver and saving the results in "result" attribute.
* process_default_paths(s_cygwin_path: str, s_solver_path: str) -> (str, str). Return the cygwin and solver paths according to the system platform. keeps them unchanged if given as input.
* build(parameters: dict). Write the model parameters dictionary to the input configuration file for the C++ solver. Also initializes the s_input_file, s_output_prefix and s_id_suffix attributes according to the given model parameters.
* execute(s_cygwin_path: str, s_solver_path: str, s_input_file: str) -> int. Execute the solver and return its exit code.
* load_output(s_output_path: str) -> dict. Read the solver output files and return a dictionary with the results.
